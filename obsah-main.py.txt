import json
import random
import asyncio
import time
import unicodedata
from typing import Dict, List, Any, Optional, Tuple

from fastapi import FastAPI, WebSocket, WebSocketDisconnect, APIRouter
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import sqlite3
from pathlib import Path
from datetime import datetime
from collections import defaultdict

app = FastAPI()
api_router = APIRouter(prefix="/api")
ws_router = APIRouter(prefix="/ws")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

try:
    with open("word_packages.json", "r", encoding="utf-8") as f:
        WORD_PACKAGES = json.load(f)
except FileNotFoundError:
    print("Error: word_packages.json not found! Using fallback words.")
    WORD_PACKAGES = {
        "Klasika": {
            "Vlastnost": [
                "Vzteklý", "Elegantní", "Líný", "Šťastný", "Smutný", "Zoufale veselý",
                "Rychlý", "Pomalý", "Zvědavý", "Zamračený", "Rozmarný", "Statečný",
                "Plachý", "Neohrožený", "Zamotaný", "Hrdinský", "Nešikovný", "Šikovný",
                "Tajemný", "Rozjařený", "Nesmělý", "Zvukotěsný", "Nadšený", "Apatií zmítaný"
            ],
            "Subjekt": [
                "Klaun", "Velryba", "Astronaut", "Robot", "Kočka", "Pes", "Žirafa",
                "Slon", "Drak", "Princezna", "Rytíř", "Kuchař", "Malíř", "Srdce", "Strom",
                "Auto", "Vlak", "Motocykl", "Hrad", "Dinosaurus", "Kaktus", "Lednička",
                "Kosmonaut", "Noviny"
            ],
            "Činnost": [
                "peče dort", "hraje golf", "tančí", "spí", "jí banán", "skáče přes vířivku",
                "houpá se na laně", "maluje obraz", "hází frisbee", "zpívá serenádu",
                "šíří konfety", "překonává překážky", "jí zmrzlinu", "řídí kůň", "učí se plavat",
                "kouzlí s kartami", "fotografuje západ slunce", "pěstuje květiny",
                "hledá poklad", "čte knihu", "stříhá trávu", "louská ořechy", "sledování filmů"
            ]
        },
        "Zvířata": {
            "Vlastnost": [
                "Hbitý", "Hladový", "Hrdý", "Plačtivý", "Zvukový", "Skákavý", "Noční",
                "Denní", "Plachý", "Domácí", "Divoký", "Myslící", "Chytrý", "Zpěvný",
                "Barevný", "Ochranný", "Přátelský", "Opojný", "Veselý", "Lenivý"
            ],
            "Subjekt": [
                "Lev", "Tygřík", "Velryba", "Delfín", "Koala", "Panda", "Kočka", "Pes",
                "Veverka", "Pštros", "Žirafa", "Slon", "Krokodýl", "Hroch", "Krab",
                "Motýl", "Pták", "Netopýr", "Ježek", "Králík", "Kůň", "Ovce", "Kráva", "Svišť"
            ],
            "Činnost": [
                "hledá oříšky", "plave v oceánu", "skáče přes stromy", "je na louce",
                "zpívá písničku", "dělá kotrmelce", "nosí klobouk", "běhá maraton",
                "střídavě spí", "loví ryby", "žvýká trávu", "hází balónem", "hraje na housle",
                "překonává stezku", "maluje stopami", "čte mapu", "dělá salto", "rozcvičuje se",
                "skrývá se v keři", "tancuje v dešti"
            ]
        },
        "Sporty": {
            "Vlastnost": [
                "Agilní", "Soutěživý", "Odolný", "Silný", "Šikovný", "Rychlý", "Výbušný",
                "Vytrvalý", "Precizní", "Kreativní", "Strategický", "Obratný", "Soustředěný",
                "Riskující", "Technický", "Elegantní", "Explozivní", "Zkušený", "Neústupný", "Přesný"
            ],
            "Subjekt": [
                "Fotbalista", "Basketbalista", "Tenista", "Plavec", "Hráč hokeje", "Běžec",
                "Cyklista", "Gymnast", "Skokan", "Boxer", "Judista", "Lyžař", "Snowboardista",
                "Skateboardista", "Surfař", "Brankář", "Rychlobruslař", "Golfista", "Stolní tenista", "Raketář"
            ],
            "Činnost": [
                "kopá penalty", "střílí trojky", "podává servisy", "plave motýlek", "brání gól",
                "běží sprint", "šlape do pedálů", "provádí salto", "boxuje soupeře", "háže disk",
                "skáče přes laťku", "odpalovací swing", "střílí gól", "vykopává roh", "trénuje tik",
                "přeskakuje překážky", "jízdí na kole", "jíždí na vlnách", "provádí trik", "trénuje střelbu"
            ]
        },
        "Jídlo a Pití": {
            "Vlastnost": [
                "Sladký", "Slaný", "Kořeněný", "Křupavý", "Měkký", "Krémový", "Hořký",
                "Svěží", "Voňavý", "Pikantní", "Žvýkací", "Šťavnatý", "Teplý", "Studený",
                "Nakládaný", "Grilovaný", "Pečený", "Různorodý", "Exotický", "Domácí"
            ],
            "Subjekt": [
                "Pizza", "Hamburger", "Sushi", "Taco", "Palačinka", "Zmrzlina", "Knedlík",
                "Salát", "Polévka", "Steak", "Grilované kuře", "Špagety", "Sendvič", "Těstoviny",
                "Sýr", "Muffin", "Bageta", "Kafe", "Čaj", "Smoothie", "Sýr", "Pirožek", "Rohlík", "Čokoláda"
            ],
            "Činnost": [
                "peče dort", "míchá koktejl", "smaží hranolky", "krájí zeleninu", "dusí rýži",
                "griluje maso", "míchá salát", "loupá ovoce", "zalévá kávu", "šlehává smetanu",
                "obsluhuje zákazníky", "balí sendviče", "podává dezert", "ochutnává polévku",
                "taví sýr", "mixuje smoothie", "peče chleba", "nakládá zeleninu", "servíruje sushi", "zmrzuje zmrzlinu"
            ]
        },
        "Filmy a Postavy": {
            "Vlastnost": [
                "Heroický", "Zlomyslný", "Komický", "Tajuplný", "Romantický", "Melancholický",
                "Šílený", "Rozverný", "Elegantní", "Mystický", "Neohrožený", "Zaváhající",
                "Vznešený", "Ironický", "Sarkastický", "Inspirativní", "Smutný", "Nekonvenční", "Chytrý", "Zoufalý"
            ],
            "Subjekt": [
                "Superhrdina", "Padouch", "Detektiv", "Piráti", "Princezna", "Vědec", "Robot",
                "Cizinec", "Vlkodlak", "Čaroděj", "Krotitel draků", "Šerif", "Kosmonaut", "Cestovatel",
                "Kaskadér", "Režisér", "Herec", "Barman", "Novinář", "Knihovník", "Kouzelník", "Zloděj", "Špión", "Námořník"
            ],
            "Činnost": [
                "zachraňuje svět", "plánuje loupež", "vyšetřuje vraždu", "plachtí po oceánu",
                "bojuje s padouchem", "tančí na střeše", "řídí vesmírnou loď", "skrývá tajemství",
                "vymýšlí vynález", "dobývá hrad", "hledá stříbrný meč", "vypíjí elixír", "píše scénář",
                "hledá lásku", "pronásleduje stopu", "provádí kaskadérské kousky", "podvádí v karetním klubu",
                "zpívá duet", "utíká před policií", "naviguje bouři"
            ]
        }
    }

GAME_SETTINGS = {
    "ROUND_DURATION": 90,
    "POINTS_BASE_GUESS": 10,
    "POINTS_ARTIST_PER_GUESS": 5,
    "TOTAL_ROUNDS_PER_PLAYER": 1, # Each player gets to be the artist once
    "POST_ROUND_DELAY": 5,
}


class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, List[WebSocket]] = {}
        self.game_states: Dict[str, Dict[str, Any]] = {}

    def get_player_websocket(self, game_code: str, username: str) -> Optional[WebSocket]:
        """Helper to find a player's websocket."""
        game_state = self.game_states.get(game_code)
        if game_state:
            for player in game_state["players"]:
                if player["username"] == username:
                    return player["websocket"]
        return None

    async def connect(self, websocket: WebSocket, game_code: str, username: str):
        # Validate game code format (6 alphanumeric characters)
        if not game_code or len(game_code) != 6 or not game_code.isalnum():
            await websocket.close(code=1008, reason="Neplatný kód hry. Kód musí obsahovat 6 alfanumerických znaků.")
            return
        
        # Validate username
        if not username or len(username.strip()) == 0:
            await websocket.close(code=1008, reason="Uživatelské jméno nesmí být prázdné.")
            return
        
        if len(username) > 20:
            await websocket.close(code=1008, reason="Uživatelské jméno je příliš dlouhé (max. 20 znaků).")
            return

        await websocket.accept()
        is_new_game = game_code not in self.active_connections

        if is_new_game:
            # Creating a new game - this is allowed
            self.active_connections[game_code] = []
            default_package = list(WORD_PACKAGES.keys())[0]
            self.game_states[game_code] = {
                "players": [], "scores": {}, "current_round": 0, "total_rounds": 3,
                "current_artist": None, "selected_phrase": [], "masked_phrase": "",
                "host": username, "selected_package": default_package, "game_started": False
            }
        else:
            # Joining existing game - check if game exists
            if game_code not in self.game_states:
                await websocket.close(code=1008, reason="Hra s tímto kódem neexistuje.")
                return

        game_state = self.game_states[game_code]
        if game_state["game_started"]:
            await websocket.close(code=1008, reason="Hra již probíhá.")
            return
        
        # Check if username is already taken in this game
        existing_usernames = [p["username"] for p in game_state["players"]]
        if username in existing_usernames:
            await websocket.close(code=1008, reason="Uživatelské jméno je již obsazeno v této hře.")
            return

        self.active_connections[game_code].append(websocket)
        game_state["players"].append({"username": username, "websocket": websocket})
        game_state["scores"][username] = 0

        # Pošleme osobní zprávu nově připojenému websocketu s aktuálním stavem hráčů,
        # aby klient nezmeškal první aktualizaci, pokud broadcast dorazí dříve než
        # klient zaregistruje svůj onmessage handler.
        await self.send_personal_message({
            "type": "player_joined",
            "username": username,
            "players": [{"username": p["username"]} for p in game_state["players"]],
            "host": game_state["host"]
        }, websocket)

        # Následně broadcastujeme ke všem (včetně nově připojeného), aby ostatní klienti
        # dostali informaci o novém hráči.
        await self.broadcast(game_code, {
            "type": "player_joined", "username": username,
            "players": [{"username": p["username"]} for p in game_state["players"]],
            "host": game_state["host"]
        })

        if game_state["host"] == username:
            await self.send_personal_message({
                "type": "available_packages", "packages": list(WORD_PACKAGES.keys()),
                "selected_package": game_state["selected_package"]
            }, websocket)

    async def disconnect(self, websocket: WebSocket, game_code: str, username: str):
        if game_code not in self.game_states:
            return

        game_state = self.game_states[game_code]
        original_host = game_state["host"]

        self.active_connections[game_code] = [conn for conn in self.active_connections[game_code] if conn != websocket]
        game_state["players"] = [p for p in game_state["players"] if p["username"] != username]
        if username in game_state["scores"]:
            del game_state["scores"][username]

        if not game_state["players"]:
            del self.active_connections[game_code]
            del self.game_states[game_code]
            return

        # If the host disconnected, assign a new one.
        # Also handles the case where the new host might be the only one left.
        if original_host == username and game_state["players"]:
            new_host = game_state["players"][0]["username"]
            game_state["host"] = new_host
            
            await self.broadcast(game_code, {"type": "new_host", "host": new_host})
            # Send package list to the new host
            new_host_ws = self.get_player_websocket(game_code, new_host)
            if new_host_ws:
                await self.send_personal_message({
                    "type": "available_packages", "packages": list(WORD_PACKAGES.keys()),
                    "selected_package": game_state["selected_package"]
                }, new_host_ws)

        await self.broadcast(game_code, {
            "type": "player_left", "username": username,
            "players": [{"username": p["username"]} for p in game_state["players"]]
        })

    async def send_personal_message(self, message: dict, websocket: WebSocket):
        await websocket.send_json(message)

    async def broadcast(self, game_code: str, message: dict):
        if game_code in self.active_connections:
            # Send concurrently to all connections and ignore failures per connection
            coros = []
            for connection in list(self.active_connections[game_code]):
                async def safe_send(conn):
                    try:
                        await conn.send_json(message)
                    except Exception:
                        # On failure, attempt to remove dead connection
                        try:
                            self.active_connections[game_code].remove(conn)
                        except Exception:
                            pass
                coros.append(safe_send(connection))
            # fire-and-forget but await to let asyncio schedule sends without blocking the main loop
            await asyncio.gather(*coros, return_exceptions=True)
manager = ConnectionManager()

# Initialize SQLite DB for leaderboard/history
DB_PATH = Path("games.db")
_conn: sqlite3.Connection = sqlite3.connect(str(DB_PATH), check_same_thread=False)
def init_db():
    cur = _conn.cursor()
    cur.execute("""
    CREATE TABLE IF NOT EXISTS games (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        game_code TEXT,
        timestamp REAL,
        winner TEXT,
        winner_score INTEGER,
        scores_json TEXT
    )
    """)
    _conn.commit()

init_db()

def _save_game_result_sync(game_code: str, scores: dict) -> None:
    # Determine winner
    if not scores:
        winner = None
        winner_score = 0
    else:
        winner, winner_score = max(scores.items(), key=lambda kv: kv[1])
    cur = _conn.cursor()
    cur.execute(
        "INSERT INTO games (game_code, timestamp, winner, winner_score, scores_json) VALUES (?, ?, ?, ?, ?)",
        (game_code, time.time(), winner, int(winner_score) if winner is not None else 0, json.dumps(scores, ensure_ascii=False)),
    )
    _conn.commit()

async def save_game_result(game_code: str, scores: dict):
    loop = asyncio.get_event_loop()
    await loop.run_in_executor(None, _save_game_result_sync, game_code, scores)

@api_router.get('/leaderboard/top')
async def get_top_leaderboard(limit: int = 10):
    cur = _conn.cursor()
    cur.execute("SELECT game_code, timestamp, winner, winner_score FROM games WHERE winner IS NOT NULL ORDER BY winner_score DESC LIMIT ?", (limit,))
    rows = cur.fetchall()
    result = []
    for game_code, ts, winner, winner_score in rows:
        result.append({
            'game_code': game_code,
            'timestamp': datetime.fromtimestamp(ts).isoformat(),
            'winner': winner,
            'winner_score': winner_score,
        })
    return JSONResponse(result)

@api_router.get('/games')
async def get_games(limit: int = 50):
    cur = _conn.cursor()
    cur.execute("SELECT id, game_code, timestamp, winner, winner_score, scores_json FROM games ORDER BY id DESC LIMIT ?", (limit,))
    rows = cur.fetchall()
    result = []
    for id_, game_code, ts, winner, winner_score, scores_json in rows:
        try:
            scores = json.loads(scores_json) if scores_json else {}
        except Exception:
            scores = {}
        result.append({
            'id': id_,
            'game_code': game_code,
            'timestamp': datetime.fromtimestamp(ts).isoformat(),
            'winner': winner,
            'winner_score': winner_score,
            'scores': scores,
        })
    return JSONResponse(result)


@api_router.get('/leaderboard/aggregate')
async def get_aggregated_leaderboard(limit: int = 50):
    """Return aggregated leaderboard across all games: total score, games played, wins, highest score, average score."""
    cur = _conn.cursor()
    cur.execute("SELECT timestamp, winner, scores_json FROM games")
    rows = cur.fetchall()

    stats: Dict[str, Dict[str, Any]] = {}
    for ts, winner, scores_json in rows:
        try:
            scores = json.loads(scores_json) if scores_json else {}
        except Exception:
            continue
        for player, sc in scores.items():
            try:
                sc_int = int(sc)
            except Exception:
                try:
                    sc_int = int(float(sc))
                except Exception:
                    sc_int = 0
            ent = stats.setdefault(player, {"total_score": 0, "games_played": 0, "wins": 0, "highest_score": 0, "last_seen": 0})
            ent["total_score"] += sc_int
            ent["games_played"] += 1
            if sc_int > ent["highest_score"]:
                ent["highest_score"] = sc_int
            if ts and ts > ent["last_seen"]:
                ent["last_seen"] = ts
        if winner:
            stats.setdefault(winner, {"total_score": 0, "games_played": 0, "wins": 0, "highest_score": 0, "last_seen": 0})["wins"] += 1

    # Prepare list with computed averages and formatted timestamps
    out = []
    for player, ent in stats.items():
        avg = ent["total_score"] / ent["games_played"] if ent["games_played"] else 0
        out.append({
            "player": player,
            "total_score": ent["total_score"],
            "games_played": ent["games_played"],
            "wins": ent["wins"],
            "highest_score": ent["highest_score"],
            "average_score": round(avg, 2),
            "last_seen": datetime.fromtimestamp(ent["last_seen"]).isoformat() if ent["last_seen"] else None,
        })

    out.sort(key=lambda x: x["total_score"], reverse=True)
    return JSONResponse(out[:limit])


@api_router.get('/leaderboard/player/{username}')
async def get_player_stats(username: str, recent_limit: int = 10):
    """Return aggregated stats for a specific player and recent game history entries where they participated."""
    cur = _conn.cursor()
    cur.execute("SELECT id, game_code, timestamp, winner, winner_score, scores_json FROM games ORDER BY id DESC")
    rows = cur.fetchall()

    total_score = 0
    games_played = 0
    wins = 0
    highest_score = 0
    recent_games = []

    for id_, game_code, ts, winner, winner_score, scores_json in rows:
        try:
            scores = json.loads(scores_json) if scores_json else {}
        except Exception:
            scores = {}
        if username in scores:
            try:
                sc = int(scores[username])
            except Exception:
                try:
                    sc = int(float(scores[username]))
                except Exception:
                    sc = 0
            total_score += sc
            games_played += 1
            if sc > highest_score:
                highest_score = sc
            is_winner = (winner == username)
            if is_winner:
                wins += 1
            if len(recent_games) < recent_limit:
                recent_games.append({
                    'id': id_,
                    'game_code': game_code,
                    'timestamp': datetime.fromtimestamp(ts).isoformat(),
                    'score': sc,
                    'winner': winner,
                    'is_winner': is_winner,
                })

    avg = total_score / games_played if games_played else 0
    result = {
        'player': username,
        'total_score': total_score,
        'games_played': games_played,
        'wins': wins,
        'highest_score': highest_score,
        'average_score': round(avg, 2),
        'recent_games': recent_games,
    }
    return JSONResponse(result)

def get_words_for_round(package_name: str):
    package = WORD_PACKAGES.get(package_name, list(WORD_PACKAGES.values())[0])
    return {
        "Vlastnost": random.sample(package["Vlastnost"], min(3, len(package["Vlastnost"]))),
        "Subjekt": random.sample(package["Subjekt"], min(3, len(package["Subjekt"]))),
        "Činnost": random.sample(package["Činnost"], min(3, len(package["Činnost"]))),
    }

@ws_router.websocket("/{game_code}/{username}")
async def websocket_endpoint(websocket: WebSocket, game_code: str, username: str):
    await manager.connect(websocket, game_code, username)
    try:
        while True:
            data = await websocket.receive_text()
            message = json.loads(data)
            game_state = manager.game_states.get(game_code)
            if not game_state: break

            if message["type"] == "select_package" and game_state["host"] == username:
                package_name = message.get("package")
                if package_name in WORD_PACKAGES:
                    game_state["selected_package"] = package_name
                    await manager.broadcast(game_code, {"type": "package_selected", "package": package_name})

            elif message["type"] == "start_game" and game_state["host"] == username:
                game_state["game_started"] = True
                game_state["total_rounds"] = len(game_state["players"]) * GAME_SETTINGS["TOTAL_ROUNDS_PER_PLAYER"]
                await start_round(game_code)

            elif message["type"] == "select_phrase" and game_state["current_artist"] == username:
                selected_phrase = message["phrase"]
                game_state["selected_phrase"] = selected_phrase
                # Create masked phrase - split "Činnost" (last element) into words for partial matching
                masked_parts = []
                for i, word in enumerate(selected_phrase):
                    if i == len(selected_phrase) - 1:  # Last element (Činnost)
                        # Split activity into words and mask each word separately
                        activity_words = word.split()
                        masked_parts.extend(["_" * len(w) for w in activity_words])
                    else:
                        masked_parts.append("_" * len(word))
                game_state["masked_phrase"] = " ".join(masked_parts)
                # Store activity words separately for matching
                game_state["activity_words"] = selected_phrase[-1].split() if len(selected_phrase) > 0 else []
                game_state["revealed_activity_words"] = [False] * len(game_state["activity_words"])
                full_phrase = " ".join(selected_phrase)
                # Send full phrase to artist
                artist_ws = manager.get_player_websocket(game_code, username)
                if artist_ws:
                    await manager.send_personal_message({
                        "type": "phrase_selected",
                        "masked_phrase": game_state["masked_phrase"],
                        "full_phrase": full_phrase
                    }, artist_ws)
                # Broadcast masked phrase to all other players (excluding artist)
                if game_code in manager.active_connections:
                    for connection in manager.active_connections[game_code]:
                        # Skip the artist's connection
                        is_artist = False
                        for player in game_state["players"]:
                            if player["websocket"] == connection and player["username"] == username:
                                is_artist = True
                                break
                        if not is_artist:
                            await connection.send_json({"type": "phrase_selected", "masked_phrase": game_state["masked_phrase"]})
                game_state["round_timer"] = asyncio.create_task(round_timer(game_code, GAME_SETTINGS["ROUND_DURATION"]))
                game_state["round_start_time"] = time.time()

            elif message["type"] == "drawing_data" and game_state["current_artist"] == username:
                await manager.broadcast(game_code, {"type": "drawing_update", "data": message["data"]})

            elif message["type"] == "clear_canvas" and game_state["current_artist"] == username:
                await manager.broadcast(game_code, {"type": "canvas_cleared"})

            elif message["type"] == "guess" and game_state["current_artist"] != username:
                await handle_guess(game_code, username, message["guess"])

    except WebSocketDisconnect:
        await manager.disconnect(websocket, game_code, username)
    except Exception as e:
        print(f"WebSocket error: {e}")
        await manager.disconnect(websocket, game_code, username)

def normalize_word(word: str) -> str:
    """
    Normalize word for comparison - lowercase, strip, remove extra spaces and diacritics.
    """
    nfkd_form = unicodedata.normalize('NFD', word)
    only_ascii = "".join([c for c in nfkd_form if not unicodedata.combining(c)])
    return only_ascii.strip().lower()

def calculate_tiered_speed_bonus(elapsed_time: float) -> int:
    """
    Calculates the speed bonus based on tiered time brackets.
    """
    if elapsed_time <= 15:
        return 50  # Bleskový bonus
    elif elapsed_time <= 40:
        return 30  # Zlatý bonus
    elif elapsed_time <= 70:
        return 15  # Stříbrný bonus
    else:
        return 5   # Bronzový bonus

def check_guess(game_state: Dict[str, Any], guess_normalized: str) -> Tuple[bool, str]:
    """
    Checks if a guess is correct against the current phrase.
    Returns a tuple: (is_correct, revealed_word).
    """
    revealed_phrase_list = game_state["masked_phrase"].split()
    selected_phrase = game_state["selected_phrase"]

    # Check Vlastnost and Subjekt (indices 0 and 1)
    for i in range(len(selected_phrase) - 1):
        word = selected_phrase[i]
        if normalize_word(word) == guess_normalized and revealed_phrase_list[i].startswith("_"):
            revealed_phrase_list[i] = word
            game_state["masked_phrase"] = " ".join(revealed_phrase_list)
            return True, word

    # Check Činnost (last part of the phrase)
    activity_words = game_state.get("activity_words", [])
    revealed_activity = game_state.get("revealed_activity_words", [])
    activity_start_idx = len(selected_phrase) - 1

    if not activity_words: # Fallback if not initialized
        last_word = selected_phrase[-1] if selected_phrase else ""
        activity_words = last_word.split()
        game_state["activity_words"] = activity_words
        revealed_activity = [False] * len(activity_words)
        game_state["revealed_activity_words"] = revealed_activity

    for j, activity_word in enumerate(activity_words):
        if normalize_word(activity_word) == guess_normalized and not revealed_activity[j]:
            activity_word_idx = activity_start_idx + j
            if activity_word_idx < len(revealed_phrase_list):
                revealed_phrase_list[activity_word_idx] = activity_word
                revealed_activity[j] = True
                game_state["revealed_activity_words"] = revealed_activity
                game_state["masked_phrase"] = " ".join(revealed_phrase_list)
                return True, activity_word

    return False, ""


async def handle_guess(game_code: str, username: str, guess: str):
    game_state = manager.game_states.get(game_code)
    if not game_state or not game_state["selected_phrase"]: return

    guess_normalized = normalize_word(guess)
    if not guess_normalized:  # Empty guess
        return

    correct_guess, revealed_word = check_guess(game_state, guess_normalized)

    if correct_guess:
        # Calculate points with speed bonus
        round_start_time = game_state.get("round_start_time", time.time())
        elapsed_time = time.time() - round_start_time
        speed_bonus = calculate_tiered_speed_bonus(elapsed_time)
        base_points = GAME_SETTINGS["POINTS_BASE_GUESS"]
        points_earned = base_points + speed_bonus
        
        game_state["scores"][username] = game_state["scores"].get(username, 0) + points_earned
        
        # Artist gets points for each correctly guessed word (base 5 points)
        artist = game_state["current_artist"]
        artist_points = GAME_SETTINGS["POINTS_ARTIST_PER_GUESS"]
        if artist in game_state["scores"]:
            game_state["scores"][artist] += artist_points

        await manager.broadcast(game_code, {
            "type": "word_guessed",
            "guesser": username,
            "word": revealed_word,
            "revealed_phrase": game_state["masked_phrase"],
            "scores": game_state["scores"],
            "points_earned": points_earned,
            "speed_bonus": speed_bonus,
            "artist_points": artist_points if artist else 0
        })
        if "_" not in game_state["masked_phrase"]:
            if game_state.get("round_timer"): game_state["round_timer"].cancel()
            await end_round(game_code)
    else:
        await manager.broadcast(game_code, {"type": "chat_message", "username": username, "message": guess})

async def round_timer(game_code: str, duration: int):
    try:
        await asyncio.sleep(duration)
        if game_code in manager.game_states:
            await end_round(game_code)
    except asyncio.CancelledError:
        # Timer was cancelled, which is expected when round ends early
        pass


async def start_round(game_code: str):
    game_state = manager.game_states.get(game_code)
    if not game_state or not game_state["players"]: return

    game_state["current_round"] += 1
    if game_state["current_round"] > game_state["total_rounds"]:
        await end_game(game_code)
        return

    game_state["selected_phrase"], game_state["masked_phrase"] = [], ""
    game_state["round_start_time"] = None  # Reset round start time
    game_state["activity_words"] = []
    game_state["revealed_activity_words"] = []

    artist_index = (game_state["current_round"] - 1) % len(game_state["players"])
    game_state["current_artist"] = game_state["players"][artist_index]["username"]

    await manager.broadcast(game_code, {
        "type": "round_start", "round": game_state["current_round"],
        "total_rounds": game_state["total_rounds"],
        "artist": game_state["current_artist"],
        "duration": GAME_SETTINGS["ROUND_DURATION"]
    })

    words = get_words_for_round(game_state["selected_package"])
    artist_ws = manager.get_player_websocket(game_code, game_state["current_artist"])
    if artist_ws:
        await manager.send_personal_message({"type": "select_phrase_options", "words": words}, artist_ws)
    else:
        # If artist disconnected, skip to next round after a short delay
        await asyncio.sleep(1)
        await start_round(game_code)


async def end_round(game_code: str):
    game_state = manager.game_states.get(game_code)
    if not game_state: return

    full_phrase = " ".join(game_state["selected_phrase"])
    await manager.broadcast(game_code, {"type": "round_end", "full_phrase": full_phrase, "scores": game_state["scores"]})

    if game_state.get("round_timer"): game_state["round_timer"].cancel()

    await asyncio.sleep(GAME_SETTINGS["POST_ROUND_DELAY"])
    await start_round(game_code)

async def end_game(game_code: str):
    game_state = manager.game_states.get(game_code)
    if not game_state: return

    # Persist results before broadcasting
    try:
        await save_game_result(game_code, game_state.get("scores", {}))
    except Exception as e:
        print(f"Warning: failed to persist game result: {e}")

    await manager.broadcast(game_code, {"type": "game_end", "final_scores": game_state["scores"]})

    await asyncio.sleep(2)
    if game_code in manager.active_connections:
        for conn in manager.active_connections[game_code]:
            try:
                await conn.close(code=1000)
            except Exception:
                pass
        try:
            del manager.active_connections[game_code]
        except Exception:
            pass
        try:
            del manager.game_states[game_code]
        except Exception:
            pass

@api_router.get("/")
async def get_root():
    return {"message": "Vítejte v backendu Koncept Kreslíři!"}
@api_router.get('/leaderboard/ranking')
async def get_leaderboard_ranking(limit: int = 50):
    """Return leaderboard ranked primarily by wins, then average score, then total score."""
    cur = _conn.cursor()
    cur.execute("SELECT timestamp, winner, scores_json FROM games")
    rows = cur.fetchall()

    stats: Dict[str, Dict[str, Any]] = {}
    for ts, winner, scores_json in rows:
        try:
            scores = json.loads(scores_json) if scores_json else {}
        except Exception:
            continue
        for player, sc in scores.items():
            try:
                sc_int = int(sc)
            except Exception:
                try:
                    sc_int = int(float(sc))
                except Exception:
                    sc_int = 0
            ent = stats.setdefault(player, {"total_score": 0, "games_played": 0, "wins": 0, "scores_list": [], "last_seen": 0})
            ent["total_score"] += sc_int
            ent["games_played"] += 1
            ent["scores_list"].append(sc_int)
            if ts and ts > ent["last_seen"]:
                ent["last_seen"] = ts
        if winner:
            stats.setdefault(winner, {"total_score": 0, "games_played": 0, "wins": 0, "scores_list": [], "last_seen": 0})["wins"] += 1

    out = []
    for player, ent in stats.items():
        avg = sum(ent["scores_list"]) / len(ent["scores_list"]) if ent["scores_list"] else 0
        out.append({
            "player": player,
            "wins": ent.get("wins", 0),
            "total_score": ent.get("total_score", 0),
            "games_played": ent.get("games_played", 0),
            "average_score": round(avg, 2),
            "last_seen": datetime.fromtimestamp(ent["last_seen"]).isoformat() if ent["last_seen"] else None,
        })

    # sort by wins desc, then average_score desc, then total_score desc
    out.sort(key=lambda x: (x["wins"], x["average_score"], x["total_score"]), reverse=True)
    return JSONResponse(out[:limit])

app.include_router(api_router)
app.include_router(ws_router)